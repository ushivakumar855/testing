{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { writeCrc } from './helpers/crc';\nimport { writeSignature } from './helpers/signature';\nimport { encodetEXt } from './helpers/text';\nimport { InterlaceMethod, ColorType, CompressionMethod, FilterMethod } from './internalTypes';\nconst defaultZlibOptions = {\n  level: 3\n};\nexport default class PngEncoder extends IOBuffer {\n  _png;\n  _zlibOptions;\n  _colorType;\n  _interlaceMethod;\n  constructor(data, options = {}) {\n    super();\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = {\n      ...defaultZlibOptions,\n      ...options.zlib\n    };\n    this._png = this._checkData(data);\n    this._interlaceMethod = (options.interlace === 'Adam7' ? InterlaceMethod.ADAM7 : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;\n    this.setBigEndian();\n  }\n  encode() {\n    writeSignature(this);\n    this.encodeIHDR();\n    if (this._png.palette) {\n      this.encodePLTE();\n      if (this._png.palette[0].length === 4) {\n        this.encodeTRNS();\n      }\n    }\n    this.encodeData();\n    if (this._png.text) {\n      for (const [keyword, text] of Object.entries(this._png.text)) {\n        encodetEXt(this, keyword, text);\n      }\n    }\n    this.encodeIEND();\n    return this.toArray();\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  encodeIHDR() {\n    this.writeUint32(13);\n    this.writeChars('IHDR');\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(this._interlaceMethod);\n    writeCrc(this, 17);\n  }\n  // https://www.w3.org/TR/PNG/#11IEND\n  encodeIEND() {\n    this.writeUint32(0);\n    this.writeChars('IEND');\n    writeCrc(this, 4);\n  }\n  encodePLTE() {\n    const paletteLength = this._png.palette?.length * 3;\n    this.writeUint32(paletteLength);\n    this.writeChars('PLTE');\n    for (const color of this._png.palette) {\n      this.writeByte(color[0]);\n      this.writeByte(color[1]);\n      this.writeByte(color[2]);\n    }\n    writeCrc(this, 4 + paletteLength);\n  }\n  encodeTRNS() {\n    const alpha = this._png.palette.filter(color => {\n      return color.at(-1) !== 255;\n    });\n    this.writeUint32(alpha.length);\n    this.writeChars('tRNS');\n    for (const el of alpha) {\n      this.writeByte(el.at(-1));\n    }\n    writeCrc(this, 4 + alpha.length);\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  encodeIDAT(data) {\n    this.writeUint32(data.length);\n    this.writeChars('IDAT');\n    this.writeBytes(data);\n    writeCrc(this, data.length + 4);\n  }\n  encodeData() {\n    const {\n      width,\n      height,\n      channels,\n      depth,\n      data\n    } = this._png;\n    const slotsPerLine = depth <= 8 ? Math.ceil(width * depth / 8) * channels : Math.ceil(width * depth / 8 * channels / 2);\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      for (let i = 0; i < height; i++) {\n        newData.writeByte(0); // no filter\n        if (depth === 16) {\n          offset = writeDataUint16(data, newData, slotsPerLine, offset);\n        } else {\n          offset = writeDataBytes(data, newData, slotsPerLine, offset);\n        }\n      }\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      // Adam7 interlacing\n      offset = writeDataInterlaced(this._png, data, newData, offset);\n    }\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n  _checkData(data) {\n    const {\n      colorType,\n      channels,\n      depth\n    } = getColorType(data, data.palette);\n    const png = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels,\n      data: data.data,\n      depth,\n      text: data.text,\n      palette: data.palette\n    };\n    this._colorType = colorType;\n    const expectedSize = depth < 8 ? Math.ceil(png.width * depth / 8) * png.height * channels : png.width * png.height * channels;\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n    }\n    return png;\n  }\n}\nfunction checkInteger(value, name) {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n  throw new TypeError(`${name} must be a positive integer`);\n}\nfunction getColorType(data, palette) {\n  const {\n    channels = 4,\n    depth = 8\n  } = data;\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(`unsupported number of channels: ${channels}`);\n  }\n  const returnValue = {\n    channels,\n    depth,\n    colorType: ColorType.UNKNOWN\n  };\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n    case 1:\n      if (palette) {\n        returnValue.colorType = ColorType.INDEXED_COLOUR;\n      } else {\n        returnValue.colorType = ColorType.GREYSCALE;\n      }\n      break;\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n    default:\n      throw new Error('unsupported number of channels');\n  }\n  return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n  return offset;\n}\nfunction writeDataInterlaced(imageData, data, newData, offset) {\n  const passes = [{\n    x: 0,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  }, {\n    x: 4,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  }, {\n    x: 0,\n    y: 4,\n    xStep: 4,\n    yStep: 8\n  }, {\n    x: 2,\n    y: 0,\n    xStep: 4,\n    yStep: 4\n  }, {\n    x: 0,\n    y: 2,\n    xStep: 2,\n    yStep: 4\n  }, {\n    x: 1,\n    y: 0,\n    xStep: 2,\n    yStep: 2\n  }, {\n    x: 0,\n    y: 1,\n    xStep: 1,\n    yStep: 2\n  }];\n  const {\n    width,\n    height,\n    channels,\n    depth\n  } = imageData;\n  let pixelSize = 0;\n  if (depth === 16) {\n    pixelSize = channels * depth / 8 / 2;\n  } else {\n    pixelSize = channels * depth / 8;\n  }\n  // Process each pass\n  for (let passIndex = 0; passIndex < 7; passIndex++) {\n    const pass = passes[passIndex];\n    const passWidth = Math.floor((width - pass.x + pass.xStep - 1) / pass.xStep);\n    const passHeight = Math.floor((height - pass.y + pass.yStep - 1) / pass.yStep);\n    if (passWidth <= 0 || passHeight <= 0) continue;\n    const passLineBytes = passWidth * pixelSize;\n    // For each scanline in this pass\n    for (let y = 0; y < passHeight; y++) {\n      const imageY = pass.y + y * pass.yStep;\n      // Extract raw scanline data\n      const rawScanline = depth <= 8 ? new Uint8Array(passLineBytes) : new Uint16Array(passLineBytes);\n      let rawOffset = 0;\n      for (let x = 0; x < passWidth; x++) {\n        const imageX = pass.x + x * pass.xStep;\n        if (imageX < width && imageY < height) {\n          const srcPos = (imageY * width + imageX) * pixelSize;\n          for (let i = 0; i < pixelSize; i++) {\n            rawScanline[rawOffset++] = data[srcPos + i];\n          }\n        }\n      }\n      newData.writeByte(0); // no filter\n      if (depth === 8) {\n        newData.writeBytes(rawScanline);\n      } else if (depth === 16) {\n        for (const value of rawScanline) {\n          newData.writeByte(value >> 8 & 0xff); // High byte\n          newData.writeByte(value & 0xff);\n        }\n      }\n    }\n  }\n  return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n  return offset;\n}","map":{"version":3,"names":["IOBuffer","deflate","writeCrc","writeSignature","encodetEXt","InterlaceMethod","ColorType","CompressionMethod","FilterMethod","defaultZlibOptions","level","PngEncoder","_png","_zlibOptions","_colorType","_interlaceMethod","constructor","data","options","UNKNOWN","zlib","_checkData","interlace","ADAM7","NO_INTERLACE","setBigEndian","encode","encodeIHDR","palette","encodePLTE","length","encodeTRNS","encodeData","text","keyword","Object","entries","encodeIEND","toArray","writeUint32","writeChars","width","height","writeByte","depth","DEFLATE","ADAPTIVE","paletteLength","color","alpha","filter","at","el","encodeIDAT","writeBytes","channels","slotsPerLine","Math","ceil","newData","offset","i","writeDataUint16","writeDataBytes","writeDataInterlaced","buffer","compressed","colorType","getColorType","png","checkInteger","expectedSize","RangeError","value","name","Number","isInteger","TypeError","returnValue","TRUECOLOUR_ALPHA","TRUECOLOUR","INDEXED_COLOUR","GREYSCALE","GREYSCALE_ALPHA","Error","j","imageData","passes","x","y","xStep","yStep","pixelSize","passIndex","pass","passWidth","floor","passHeight","passLineBytes","imageY","rawScanline","Uint8Array","Uint16Array","rawOffset","imageX","srcPos","writeUint16"],"sources":["C:\\Users\\smscp\\Desktop\\Ram\\PESU 5th sem Project\\SE project\\node_modules\\fast-png\\src\\PngEncoder.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\n\nimport { writeCrc } from './helpers/crc';\nimport { writeSignature } from './helpers/signature';\nimport { encodetEXt } from './helpers/text';\nimport {\n  InterlaceMethod,\n  ColorType,\n  CompressionMethod,\n  FilterMethod,\n} from './internalTypes';\nimport type {\n  DeflateFunctionOptions,\n  PngEncoderOptions,\n  ImageData,\n  PngDataArray,\n  BitDepth,\n  IndexedColors,\n} from './types';\n\nconst defaultZlibOptions: DeflateFunctionOptions = {\n  level: 3,\n};\n\ninterface PngToEncode {\n  width: number;\n  height: number;\n  data: PngDataArray;\n  depth: BitDepth;\n  channels: number;\n  text?: ImageData['text'];\n  palette?: IndexedColors;\n}\n\nexport default class PngEncoder extends IOBuffer {\n  private readonly _png: PngToEncode;\n  private readonly _zlibOptions: DeflateFunctionOptions;\n  private _colorType: ColorType;\n  private readonly _interlaceMethod: InterlaceMethod;\n  public constructor(data: ImageData, options: PngEncoderOptions = {}) {\n    super();\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = { ...defaultZlibOptions, ...options.zlib };\n    this._png = this._checkData(data);\n\n    this._interlaceMethod =\n      (options.interlace === 'Adam7'\n        ? InterlaceMethod.ADAM7\n        : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;\n    this.setBigEndian();\n  }\n\n  public encode(): Uint8Array {\n    writeSignature(this);\n    this.encodeIHDR();\n    if (this._png.palette) {\n      this.encodePLTE();\n      if (this._png.palette[0].length === 4) {\n        this.encodeTRNS();\n      }\n    }\n\n    this.encodeData();\n    if (this._png.text) {\n      for (const [keyword, text] of Object.entries(this._png.text)) {\n        encodetEXt(this, keyword, text);\n      }\n    }\n    this.encodeIEND();\n    return this.toArray();\n  }\n\n  // https://www.w3.org/TR/PNG/#11IHDR\n  private encodeIHDR(): void {\n    this.writeUint32(13);\n\n    this.writeChars('IHDR');\n\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(this._interlaceMethod);\n\n    writeCrc(this, 17);\n  }\n\n  // https://www.w3.org/TR/PNG/#11IEND\n  private encodeIEND(): void {\n    this.writeUint32(0);\n\n    this.writeChars('IEND');\n\n    writeCrc(this, 4);\n  }\n\n  private encodePLTE() {\n    const paletteLength = (this._png.palette?.length as number) * 3;\n    this.writeUint32(paletteLength);\n    this.writeChars('PLTE');\n    for (const color of this._png.palette as IndexedColors) {\n      this.writeByte(color[0]);\n      this.writeByte(color[1]);\n      this.writeByte(color[2]);\n    }\n    writeCrc(this, 4 + paletteLength);\n  }\n\n  private encodeTRNS() {\n    const alpha = (this._png.palette as IndexedColors).filter((color) => {\n      return color.at(-1) !== 255;\n    });\n    this.writeUint32(alpha.length);\n    this.writeChars('tRNS');\n    for (const el of alpha) {\n      this.writeByte(el.at(-1) as number);\n    }\n    writeCrc(this, 4 + alpha.length);\n  }\n\n  // https://www.w3.org/TR/PNG/#11IDAT\n  private encodeIDAT(data: PngDataArray): void {\n    this.writeUint32(data.length);\n    this.writeChars('IDAT');\n\n    this.writeBytes(data);\n\n    writeCrc(this, data.length + 4);\n  }\n\n  private encodeData(): void {\n    const { width, height, channels, depth, data } = this._png;\n    const slotsPerLine =\n      depth <= 8\n        ? Math.ceil((width * depth) / 8) * channels\n        : Math.ceil((((width * depth) / 8) * channels) / 2);\n\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      for (let i = 0; i < height; i++) {\n        newData.writeByte(0); // no filter\n        if (depth === 16) {\n          offset = writeDataUint16(data, newData, slotsPerLine, offset);\n        } else {\n          offset = writeDataBytes(data, newData, slotsPerLine, offset);\n        }\n      }\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      // Adam7 interlacing\n      offset = writeDataInterlaced(this._png, data, newData, offset);\n    }\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n\n  private _checkData(data: ImageData): PngToEncode {\n    const { colorType, channels, depth } = getColorType(data, data.palette);\n\n    const png: PngToEncode = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels,\n      data: data.data,\n      depth,\n      text: data.text,\n      palette: data.palette,\n    };\n    this._colorType = colorType;\n    const expectedSize =\n      depth < 8\n        ? Math.ceil((png.width * depth) / 8) * png.height * channels\n        : png.width * png.height * channels;\n\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(\n        `wrong data size. Found ${png.data.length}, expected ${expectedSize}`,\n      );\n    }\n    return png;\n  }\n}\n\nfunction checkInteger(value: number, name: string): number {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n  throw new TypeError(`${name} must be a positive integer`);\n}\n\ninterface GetColorTypeReturn {\n  channels: number;\n  depth: BitDepth;\n  colorType: ColorType;\n}\n\nfunction getColorType(\n  data: ImageData,\n  palette?: IndexedColors,\n): GetColorTypeReturn {\n  const { channels = 4, depth = 8 } = data;\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(`unsupported number of channels: ${channels}`);\n  }\n\n  const returnValue: GetColorTypeReturn = {\n    channels,\n    depth,\n    colorType: ColorType.UNKNOWN,\n  };\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n    case 1:\n      if (palette) {\n        returnValue.colorType = ColorType.INDEXED_COLOUR;\n      } else {\n        returnValue.colorType = ColorType.GREYSCALE;\n      }\n      break;\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n    default:\n      throw new Error('unsupported number of channels');\n  }\n  return returnValue;\n}\n\nfunction writeDataBytes(\n  data: PngDataArray,\n  newData: IOBuffer,\n  slotsPerLine: number,\n  offset: number,\n): number {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n  return offset;\n}\n\nfunction writeDataInterlaced(\n  imageData: PngToEncode,\n  data: PngDataArray,\n  newData: IOBuffer,\n  offset: number,\n) {\n  const passes = [\n    { x: 0, y: 0, xStep: 8, yStep: 8 },\n    { x: 4, y: 0, xStep: 8, yStep: 8 },\n    { x: 0, y: 4, xStep: 4, yStep: 8 },\n    { x: 2, y: 0, xStep: 4, yStep: 4 },\n    { x: 0, y: 2, xStep: 2, yStep: 4 },\n    { x: 1, y: 0, xStep: 2, yStep: 2 },\n    { x: 0, y: 1, xStep: 1, yStep: 2 },\n  ];\n  const { width, height, channels, depth } = imageData;\n  let pixelSize = 0;\n  if (depth === 16) {\n    pixelSize = (channels * depth) / 8 / 2;\n  } else {\n    pixelSize = (channels * depth) / 8;\n  }\n  // Process each pass\n  for (let passIndex = 0; passIndex < 7; passIndex++) {\n    const pass = passes[passIndex];\n    const passWidth = Math.floor(\n      (width - pass.x + pass.xStep - 1) / pass.xStep,\n    );\n    const passHeight = Math.floor(\n      (height - pass.y + pass.yStep - 1) / pass.yStep,\n    );\n\n    if (passWidth <= 0 || passHeight <= 0) continue;\n    const passLineBytes = passWidth * pixelSize;\n    // For each scanline in this pass\n    for (let y = 0; y < passHeight; y++) {\n      const imageY = pass.y + y * pass.yStep;\n      // Extract raw scanline data\n      const rawScanline =\n        depth <= 8\n          ? new Uint8Array(passLineBytes)\n          : new Uint16Array(passLineBytes);\n\n      let rawOffset = 0;\n      for (let x = 0; x < passWidth; x++) {\n        const imageX = pass.x + x * pass.xStep;\n        if (imageX < width && imageY < height) {\n          const srcPos = (imageY * width + imageX) * pixelSize;\n          for (let i = 0; i < pixelSize; i++) {\n            rawScanline[rawOffset++] = data[srcPos + i];\n          }\n        }\n      }\n      newData.writeByte(0); // no filter\n      if (depth === 8) {\n        newData.writeBytes(rawScanline);\n      } else if (depth === 16) {\n        for (const value of rawScanline) {\n          newData.writeByte((value >> 8) & 0xff); // High byte\n          newData.writeByte(value & 0xff);\n        }\n      }\n    }\n  }\n  return offset;\n}\n\nfunction writeDataUint16(\n  data: PngDataArray,\n  newData: IOBuffer,\n  slotsPerLine: number,\n  offset: number,\n): number {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n  return offset;\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,UAAU;AACnC,SAASC,OAAO,QAAQ,MAAM;AAE9B,SAASC,QAAQ,QAAQ,eAAe;AACxC,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,UAAU,QAAQ,gBAAgB;AAC3C,SACEC,eAAe,EACfC,SAAS,EACTC,iBAAiB,EACjBC,YAAY,QACP,iBAAiB;AAUxB,MAAMC,kBAAkB,GAA2B;EACjDC,KAAK,EAAE;CACR;AAYD,eAAc,MAAOC,UAAW,SAAQX,QAAQ;EAC7BY,IAAI;EACJC,YAAY;EACrBC,UAAU;EACDC,gBAAgB;EACjCC,YAAmBC,IAAe,EAAEC,OAAA,GAA6B,EAAE;IACjE,KAAK,EAAE;IACP,IAAI,CAACJ,UAAU,GAAGR,SAAS,CAACa,OAAO;IACnC,IAAI,CAACN,YAAY,GAAG;MAAE,GAAGJ,kBAAkB;MAAE,GAAGS,OAAO,CAACE;IAAI,CAAE;IAC9D,IAAI,CAACR,IAAI,GAAG,IAAI,CAACS,UAAU,CAACJ,IAAI,CAAC;IAEjC,IAAI,CAACF,gBAAgB,GACnB,CAACG,OAAO,CAACI,SAAS,KAAK,OAAO,GAC1BjB,eAAe,CAACkB,KAAK,GACrBlB,eAAe,CAACmB,YAAY,KAAKnB,eAAe,CAACmB,YAAY;IACnE,IAAI,CAACC,YAAY,EAAE;EACrB;EAEOC,MAAMA,CAAA;IACXvB,cAAc,CAAC,IAAI,CAAC;IACpB,IAAI,CAACwB,UAAU,EAAE;IACjB,IAAI,IAAI,CAACf,IAAI,CAACgB,OAAO,EAAE;MACrB,IAAI,CAACC,UAAU,EAAE;MACjB,IAAI,IAAI,CAACjB,IAAI,CAACgB,OAAO,CAAC,CAAC,CAAC,CAACE,MAAM,KAAK,CAAC,EAAE;QACrC,IAAI,CAACC,UAAU,EAAE;MACnB;IACF;IAEA,IAAI,CAACC,UAAU,EAAE;IACjB,IAAI,IAAI,CAACpB,IAAI,CAACqB,IAAI,EAAE;MAClB,KAAK,MAAM,CAACC,OAAO,EAAED,IAAI,CAAC,IAAIE,MAAM,CAACC,OAAO,CAAC,IAAI,CAACxB,IAAI,CAACqB,IAAI,CAAC,EAAE;QAC5D7B,UAAU,CAAC,IAAI,EAAE8B,OAAO,EAAED,IAAI,CAAC;MACjC;IACF;IACA,IAAI,CAACI,UAAU,EAAE;IACjB,OAAO,IAAI,CAACC,OAAO,EAAE;EACvB;EAEA;EACQX,UAAUA,CAAA;IAChB,IAAI,CAACY,WAAW,CAAC,EAAE,CAAC;IAEpB,IAAI,CAACC,UAAU,CAAC,MAAM,CAAC;IAEvB,IAAI,CAACD,WAAW,CAAC,IAAI,CAAC3B,IAAI,CAAC6B,KAAK,CAAC;IACjC,IAAI,CAACF,WAAW,CAAC,IAAI,CAAC3B,IAAI,CAAC8B,MAAM,CAAC;IAClC,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC/B,IAAI,CAACgC,KAAK,CAAC;IAC/B,IAAI,CAACD,SAAS,CAAC,IAAI,CAAC7B,UAAU,CAAC;IAC/B,IAAI,CAAC6B,SAAS,CAACpC,iBAAiB,CAACsC,OAAO,CAAC;IACzC,IAAI,CAACF,SAAS,CAACnC,YAAY,CAACsC,QAAQ,CAAC;IACrC,IAAI,CAACH,SAAS,CAAC,IAAI,CAAC5B,gBAAgB,CAAC;IAErCb,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;EACpB;EAEA;EACQmC,UAAUA,CAAA;IAChB,IAAI,CAACE,WAAW,CAAC,CAAC,CAAC;IAEnB,IAAI,CAACC,UAAU,CAAC,MAAM,CAAC;IAEvBtC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;EACnB;EAEQ2B,UAAUA,CAAA;IAChB,MAAMkB,aAAa,GAAI,IAAI,CAACnC,IAAI,CAACgB,OAAO,EAAEE,MAAiB,GAAG,CAAC;IAC/D,IAAI,CAACS,WAAW,CAACQ,aAAa,CAAC;IAC/B,IAAI,CAACP,UAAU,CAAC,MAAM,CAAC;IACvB,KAAK,MAAMQ,KAAK,IAAI,IAAI,CAACpC,IAAI,CAACgB,OAAwB,EAAE;MACtD,IAAI,CAACe,SAAS,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC;MACxB,IAAI,CAACL,SAAS,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC;MACxB,IAAI,CAACL,SAAS,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1B;IACA9C,QAAQ,CAAC,IAAI,EAAE,CAAC,GAAG6C,aAAa,CAAC;EACnC;EAEQhB,UAAUA,CAAA;IAChB,MAAMkB,KAAK,GAAI,IAAI,CAACrC,IAAI,CAACgB,OAAyB,CAACsB,MAAM,CAAEF,KAAK,IAAI;MAClE,OAAOA,KAAK,CAACG,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG;IAC7B,CAAC,CAAC;IACF,IAAI,CAACZ,WAAW,CAACU,KAAK,CAACnB,MAAM,CAAC;IAC9B,IAAI,CAACU,UAAU,CAAC,MAAM,CAAC;IACvB,KAAK,MAAMY,EAAE,IAAIH,KAAK,EAAE;MACtB,IAAI,CAACN,SAAS,CAACS,EAAE,CAACD,EAAE,CAAC,CAAC,CAAC,CAAW,CAAC;IACrC;IACAjD,QAAQ,CAAC,IAAI,EAAE,CAAC,GAAG+C,KAAK,CAACnB,MAAM,CAAC;EAClC;EAEA;EACQuB,UAAUA,CAACpC,IAAkB;IACnC,IAAI,CAACsB,WAAW,CAACtB,IAAI,CAACa,MAAM,CAAC;IAC7B,IAAI,CAACU,UAAU,CAAC,MAAM,CAAC;IAEvB,IAAI,CAACc,UAAU,CAACrC,IAAI,CAAC;IAErBf,QAAQ,CAAC,IAAI,EAAEe,IAAI,CAACa,MAAM,GAAG,CAAC,CAAC;EACjC;EAEQE,UAAUA,CAAA;IAChB,MAAM;MAAES,KAAK;MAAEC,MAAM;MAAEa,QAAQ;MAAEX,KAAK;MAAE3B;IAAI,CAAE,GAAG,IAAI,CAACL,IAAI;IAC1D,MAAM4C,YAAY,GAChBZ,KAAK,IAAI,CAAC,GACNa,IAAI,CAACC,IAAI,CAAEjB,KAAK,GAAGG,KAAK,GAAI,CAAC,CAAC,GAAGW,QAAQ,GACzCE,IAAI,CAACC,IAAI,CAAIjB,KAAK,GAAGG,KAAK,GAAI,CAAC,GAAIW,QAAQ,GAAI,CAAC,CAAC;IAEvD,MAAMI,OAAO,GAAG,IAAI3D,QAAQ,EAAE,CAACyB,YAAY,EAAE;IAC7C,IAAImC,MAAM,GAAG,CAAC;IACd,IAAI,IAAI,CAAC7C,gBAAgB,KAAKV,eAAe,CAACmB,YAAY,EAAE;MAC1D,KAAK,IAAIqC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,MAAM,EAAEmB,CAAC,EAAE,EAAE;QAC/BF,OAAO,CAAChB,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;QACtB,IAAIC,KAAK,KAAK,EAAE,EAAE;UAChBgB,MAAM,GAAGE,eAAe,CAAC7C,IAAI,EAAE0C,OAAO,EAAEH,YAAY,EAAEI,MAAM,CAAC;QAC/D,CAAC,MAAM;UACLA,MAAM,GAAGG,cAAc,CAAC9C,IAAI,EAAE0C,OAAO,EAAEH,YAAY,EAAEI,MAAM,CAAC;QAC9D;MACF;IACF,CAAC,MAAM,IAAI,IAAI,CAAC7C,gBAAgB,KAAKV,eAAe,CAACkB,KAAK,EAAE;MAC1D;MACAqC,MAAM,GAAGI,mBAAmB,CAAC,IAAI,CAACpD,IAAI,EAAEK,IAAI,EAAE0C,OAAO,EAAEC,MAAM,CAAC;IAChE;IACA,MAAMK,MAAM,GAAGN,OAAO,CAACrB,OAAO,EAAE;IAChC,MAAM4B,UAAU,GAAGjE,OAAO,CAACgE,MAAM,EAAE,IAAI,CAACpD,YAAY,CAAC;IACrD,IAAI,CAACwC,UAAU,CAACa,UAAU,CAAC;EAC7B;EAEQ7C,UAAUA,CAACJ,IAAe;IAChC,MAAM;MAAEkD,SAAS;MAAEZ,QAAQ;MAAEX;IAAK,CAAE,GAAGwB,YAAY,CAACnD,IAAI,EAAEA,IAAI,CAACW,OAAO,CAAC;IAEvE,MAAMyC,GAAG,GAAgB;MACvB5B,KAAK,EAAE6B,YAAY,CAACrD,IAAI,CAACwB,KAAK,EAAE,OAAO,CAAC;MACxCC,MAAM,EAAE4B,YAAY,CAACrD,IAAI,CAACyB,MAAM,EAAE,QAAQ,CAAC;MAC3Ca,QAAQ;MACRtC,IAAI,EAAEA,IAAI,CAACA,IAAI;MACf2B,KAAK;MACLX,IAAI,EAAEhB,IAAI,CAACgB,IAAI;MACfL,OAAO,EAAEX,IAAI,CAACW;KACf;IACD,IAAI,CAACd,UAAU,GAAGqD,SAAS;IAC3B,MAAMI,YAAY,GAChB3B,KAAK,GAAG,CAAC,GACLa,IAAI,CAACC,IAAI,CAAEW,GAAG,CAAC5B,KAAK,GAAGG,KAAK,GAAI,CAAC,CAAC,GAAGyB,GAAG,CAAC3B,MAAM,GAAGa,QAAQ,GAC1Dc,GAAG,CAAC5B,KAAK,GAAG4B,GAAG,CAAC3B,MAAM,GAAGa,QAAQ;IAEvC,IAAIc,GAAG,CAACpD,IAAI,CAACa,MAAM,KAAKyC,YAAY,EAAE;MACpC,MAAM,IAAIC,UAAU,CAClB,0BAA0BH,GAAG,CAACpD,IAAI,CAACa,MAAM,cAAcyC,YAAY,EAAE,CACtE;IACH;IACA,OAAOF,GAAG;EACZ;;AAGF,SAASC,YAAYA,CAACG,KAAa,EAAEC,IAAY;EAC/C,IAAIC,MAAM,CAACC,SAAS,CAACH,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,EAAE;IACxC,OAAOA,KAAK;EACd;EACA,MAAM,IAAII,SAAS,CAAC,GAAGH,IAAI,6BAA6B,CAAC;AAC3D;AAQA,SAASN,YAAYA,CACnBnD,IAAe,EACfW,OAAuB;EAEvB,MAAM;IAAE2B,QAAQ,GAAG,CAAC;IAAEX,KAAK,GAAG;EAAC,CAAE,GAAG3B,IAAI;EACxC,IAAIsC,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC,EAAE;IACxE,MAAM,IAAIiB,UAAU,CAAC,mCAAmCjB,QAAQ,EAAE,CAAC;EACrE;EAEA,MAAMuB,WAAW,GAAuB;IACtCvB,QAAQ;IACRX,KAAK;IACLuB,SAAS,EAAE7D,SAAS,CAACa;GACtB;EACD,QAAQoC,QAAQ;IACd,KAAK,CAAC;MACJuB,WAAW,CAACX,SAAS,GAAG7D,SAAS,CAACyE,gBAAgB;MAClD;IACF,KAAK,CAAC;MACJD,WAAW,CAACX,SAAS,GAAG7D,SAAS,CAAC0E,UAAU;MAC5C;IACF,KAAK,CAAC;MACJ,IAAIpD,OAAO,EAAE;QACXkD,WAAW,CAACX,SAAS,GAAG7D,SAAS,CAAC2E,cAAc;MAClD,CAAC,MAAM;QACLH,WAAW,CAACX,SAAS,GAAG7D,SAAS,CAAC4E,SAAS;MAC7C;MACA;IACF,KAAK,CAAC;MACJJ,WAAW,CAACX,SAAS,GAAG7D,SAAS,CAAC6E,eAAe;MACjD;IACF;MACE,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;EACrD;EACA,OAAON,WAAW;AACpB;AAEA,SAASf,cAAcA,CACrB9C,IAAkB,EAClB0C,OAAiB,EACjBH,YAAoB,EACpBI,MAAc;EAEd,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,YAAY,EAAE6B,CAAC,EAAE,EAAE;IACrC1B,OAAO,CAAChB,SAAS,CAAC1B,IAAI,CAAC2C,MAAM,EAAE,CAAC,CAAC;EACnC;EACA,OAAOA,MAAM;AACf;AAEA,SAASI,mBAAmBA,CAC1BsB,SAAsB,EACtBrE,IAAkB,EAClB0C,OAAiB,EACjBC,MAAc;EAEd,MAAM2B,MAAM,GAAG,CACb;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,EAClC;IAAEH,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAC,CAAE,CACnC;EACD,MAAM;IAAElD,KAAK;IAAEC,MAAM;IAAEa,QAAQ;IAAEX;EAAK,CAAE,GAAG0C,SAAS;EACpD,IAAIM,SAAS,GAAG,CAAC;EACjB,IAAIhD,KAAK,KAAK,EAAE,EAAE;IAChBgD,SAAS,GAAIrC,QAAQ,GAAGX,KAAK,GAAI,CAAC,GAAG,CAAC;EACxC,CAAC,MAAM;IACLgD,SAAS,GAAIrC,QAAQ,GAAGX,KAAK,GAAI,CAAC;EACpC;EACA;EACA,KAAK,IAAIiD,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAG,CAAC,EAAEA,SAAS,EAAE,EAAE;IAClD,MAAMC,IAAI,GAAGP,MAAM,CAACM,SAAS,CAAC;IAC9B,MAAME,SAAS,GAAGtC,IAAI,CAACuC,KAAK,CAC1B,CAACvD,KAAK,GAAGqD,IAAI,CAACN,CAAC,GAAGM,IAAI,CAACJ,KAAK,GAAG,CAAC,IAAII,IAAI,CAACJ,KAAK,CAC/C;IACD,MAAMO,UAAU,GAAGxC,IAAI,CAACuC,KAAK,CAC3B,CAACtD,MAAM,GAAGoD,IAAI,CAACL,CAAC,GAAGK,IAAI,CAACH,KAAK,GAAG,CAAC,IAAIG,IAAI,CAACH,KAAK,CAChD;IAED,IAAII,SAAS,IAAI,CAAC,IAAIE,UAAU,IAAI,CAAC,EAAE;IACvC,MAAMC,aAAa,GAAGH,SAAS,GAAGH,SAAS;IAC3C;IACA,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,UAAU,EAAER,CAAC,EAAE,EAAE;MACnC,MAAMU,MAAM,GAAGL,IAAI,CAACL,CAAC,GAAGA,CAAC,GAAGK,IAAI,CAACH,KAAK;MACtC;MACA,MAAMS,WAAW,GACfxD,KAAK,IAAI,CAAC,GACN,IAAIyD,UAAU,CAACH,aAAa,CAAC,GAC7B,IAAII,WAAW,CAACJ,aAAa,CAAC;MAEpC,IAAIK,SAAS,GAAG,CAAC;MACjB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,SAAS,EAAEP,CAAC,EAAE,EAAE;QAClC,MAAMgB,MAAM,GAAGV,IAAI,CAACN,CAAC,GAAGA,CAAC,GAAGM,IAAI,CAACJ,KAAK;QACtC,IAAIc,MAAM,GAAG/D,KAAK,IAAI0D,MAAM,GAAGzD,MAAM,EAAE;UACrC,MAAM+D,MAAM,GAAG,CAACN,MAAM,GAAG1D,KAAK,GAAG+D,MAAM,IAAIZ,SAAS;UACpD,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,SAAS,EAAE/B,CAAC,EAAE,EAAE;YAClCuC,WAAW,CAACG,SAAS,EAAE,CAAC,GAAGtF,IAAI,CAACwF,MAAM,GAAG5C,CAAC,CAAC;UAC7C;QACF;MACF;MACAF,OAAO,CAAChB,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;MACtB,IAAIC,KAAK,KAAK,CAAC,EAAE;QACfe,OAAO,CAACL,UAAU,CAAC8C,WAAW,CAAC;MACjC,CAAC,MAAM,IAAIxD,KAAK,KAAK,EAAE,EAAE;QACvB,KAAK,MAAM6B,KAAK,IAAI2B,WAAW,EAAE;UAC/BzC,OAAO,CAAChB,SAAS,CAAE8B,KAAK,IAAI,CAAC,GAAI,IAAI,CAAC,CAAC,CAAC;UACxCd,OAAO,CAAChB,SAAS,CAAC8B,KAAK,GAAG,IAAI,CAAC;QACjC;MACF;IACF;EACF;EACA,OAAOb,MAAM;AACf;AAEA,SAASE,eAAeA,CACtB7C,IAAkB,EAClB0C,OAAiB,EACjBH,YAAoB,EACpBI,MAAc;EAEd,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,YAAY,EAAE6B,CAAC,EAAE,EAAE;IACrC1B,OAAO,CAAC+C,WAAW,CAACzF,IAAI,CAAC2C,MAAM,EAAE,CAAC,CAAC;EACrC;EACA,OAAOA,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}